#
# Author:: "Vulk Wolfpack" <wolfpack@vulk.co>
# Copyright:: Chef Inc.
#

require 'chef/knife/cloud/vcair_service_options'
require 'pry'

class Chef
  class Knife
    class Cloud
      module VcairHelpers

        def create_service_instance
          VcairService.new
        end
        
        def org
          @org ||= @service.connection.organizations.get_by_name(
                     config_value(:vcair_org))
        end

        def vdc
          if config_value(:vcair_org)
            @vdc ||= org.vdcs.get_by_name(vdc_name)
          else
            @vdc ||= org.vdcs.first
          end
        end
        
        def net
          @net ||= org.networks.find { |n| n if n.name.match("routed$") }
        end

        def template
          @template ||= org.catalogs.map do |cat|
            cat.catalog_items.get_by_name(config_value(:image))
          end.compact.first
        end
        
        def vapp
          @vapp ||= vdc.vapps.get_by_name(config_value(:chef_node_name))
        end
        
        def vm
          @vm ||= vapp.vms.find {|v| v.vapp_name == config_value(:chef_node_name)}
        end

        def network_config
          @network_config ||= vapp.network_config.find do |n|
            n if n[:networkName].match("routed$")
          end
        end
        
        def instanciate
          node_name = config_value(:chef_node_name)
          @instancate ||= template.instantiate(
                                               node_name,
                                               vdc_id: vdc.id,
                                               network_id: net.id,
                                               description: "id:#{node_name}")
        end
        
        def update_network
          ## TODO: allow user to specify network to connect to (see above net used)
          # Define network connection for vm based on existing routed network
          nc = vapp.network_config.find { |n| n if n[:networkName].match("routed$") }
          networks_config = [nc]
          section = {PrimaryNetworkConnectionIndex: 0}
          section[:NetworkConnection] = networks_config.compact.each_with_index.map do |network, i|
            connection = {
              network: network[:networkName],
              needsCustomization: true,
              NetworkConnectionIndex: i,
              IsConnected: true
            }
            ip_address      = network[:ip_address]
            ## TODO: support config options for allocation mode
            #allocation_mode = network[:allocation_mode]
            #allocation_mode = 'manual' if ip_address
            #allocation_mode = 'dhcp' unless %w{dhcp manual pool}.include?(allocation_mode)
            #allocation_mode = 'POOL'
            #connection[:Dns1] = dns1 if dns1
            allocation_mode = 'pool'
            connection[:IpAddressAllocationMode] = allocation_mode.upcase
            connection[:IpAddress] = ip_address if ip_address
            connection
          end

          ## attach the network to the vm
          nc_task = @service.connection.put_network_connection_system_section_vapp(
            vm.id,section).body
          @service.connection.process_task(nc_task)
        end

        def update_customization
          ## Initialization before first power on.
          c=vm.customization
          
          if config_value(:customization_script)
            c.script = open(config_value(:customization_script)).read
          end
          
          password = case config_value(:bootstrap_protocol)
                     when 'winrm'
                       config_value(:winrm_password)
                     when 'ssh'
                       config_value(:ssh_password)
                     end
          if password
            c.admin_password =  password 
            c.admin_password_auto = false
            c.reset_password_required = false
          else
            # Password will be autogenerated
            c.admin_password_auto=true
            # API will force password resets when auto is enabled
            c.reset_password_required = true
          end
          
          # TODO: Add support for admin_auto_logon to fog
          # c.admin_auto_logon_count = 100
          # c.admin_auto_logon_enabled = true

          # DNS and Windows want AlphaNumeric and dashes for hostnames
          c.computer_name = config_value(:chef_node_name).gsub(/\W/,"-")
          c.enabled = true
          c.save
        end

        def bootstrap_ip_address
          vm.reload
          vm.ip_address
        end

        def config_value(key)
          key = key.to_sym
          Chef::Config[:knife][key] || config[key]
        end
        
        def get_id(value)
          value['id']
        end

        def msg_pair(label, value, color=:cyan)
          if value && !value.to_s.empty?
            puts "#{ui.color(label, color)}: #{value}"
          end
        end
        
        def validate!(keys=[:vcair_username, :vcair_password, :vcair_host, :vcair_org, :vcair_api_version])
          errors = []
          keys.each do |k|
            pretty_key = k.to_s.gsub(/_/, ' ').gsub(/\w+/){ |w| (w =~ /(ssh)/i) ? w.upcase  : w.capitalize }
            if config_value(k).nil?
              errors << "You did not provide a valid '#{pretty_key}' value. Please set knife[:#{k}] in your knife.rb or pass as an option."
            end
          end
          
          if errors.each{|e| ui.error(e)}.any?
            exit 1
          end
        end
        
      end
    end
  end
end
