#
# Author:: "Vulk Wolfpack" <wolfpack@vulk.co>
# Copyright:: Chef Inc.
#

require 'chef/knife/cloud/vcair_service_options'
require 'pry'

class Chef
  class Knife
    class Cloud
      module VcairHelpers

        def create_service_instance
          VcairService.new
        end
        
        def org
          @org ||= @service.connection.organizations.get_by_name(
                     config_value(:vcair_org))
        end

        def vdc
          if config_value(:vcair_org)
            @vdc ||= org.vdcs.get_by_name(vdc_name)
          else
            @vdc ||= org.vdcs.first
          end
        end
        
        def net
          @net ||= org.networks.find { |n| n if n.name.match("routed$") }
        end

        def template
          @template ||= org.catalogs.map do |cat|
            cat.catalog_items.get_by_name(config_value(:image))
          end.compact.first
        end
        
        def vapp
          @vapp ||= vdc.vapps.get_by_name(config_value(:chef_node_name))
        end
        
        def vm
          @vm ||= vapp.vms.find {|v| v.vapp_name == config_value(:chef_node_name)}
        end

        def network_config
          @network_config ||= vapp.network_config.find do |n|
            n if n[:networkName].match("routed$")
          end
        end
        
        def instanciate
          node_name = config_value(:chef_node_name)
          @instancate ||= template.instantiate(
                                               node_name,
                                               vdc_id: vdc.id,
                                               network_id: net.id,
                                               description: "id:#{node_name}")
        end
        
        def update_network
          ## TODO: allow user to specify network to connect to (see above net used)
          # Define network connection for vm based on existing routed network
          nc = vapp.network_config.find { |n| n if n[:networkName].match("routed$") }
          networks_config = [nc]
          section = {PrimaryNetworkConnectionIndex: 0}
          section[:NetworkConnection] = networks_config.compact.each_with_index.map do |network, i|
            connection = {
              network: network[:networkName],
              needsCustomization: true,
              NetworkConnectionIndex: i,
              IsConnected: true
            }
            ip_address      = network[:ip_address]
            #allocation_mode = network[:allocation_mode]
            #allocation_mode = 'manual' if ip_address
            #allocation_mode = 'dhcp' unless %w{dhcp manual pool}.include?(allocation_mode)
            #allocation_mode = 'POOL'

            ## TODO: support config options for allocation mode
            allocation_mode = 'pool'
            connection[:IpAddressAllocationMode] = allocation_mode.upcase
            connection[:IpAddress] = ip_address if ip_address
            #connection[:Dns1] = dns1 if dns1
            connection
          end

          ## attach the network to the vm
          nc_task = @service.connection.put_network_connection_system_section_vapp(
            vm.id,section).body
          @service.connection.process_task(nc_task)
        end

        def update_customization
          ## Initialization before first power on.
          c=vm.customization
          
          if config_value(:customization_script)
            c.script = open(config_value(:customization_script)).read
          end
          
          password = case config_value(:bootstrap_protocol)
                     when 'winrm'
                       config_value(:winrm_password)
                     when 'ssh'
                       config_value(:ssh_password)
                     end
          if password
            c.admin_password =  password 
            c.admin_password_auto = false
            c.reset_password_required = false
          else
            # Password will be autogenerated
            c.admin_password_auto=true
            # API will force password resets when auto is enabled
            c.reset_password_required = true
          end
          
          # TODO: Add support for admin_auto_logon to fog
          # c.admin_auto_logon_count = 100
          # c.admin_auto_logon_enabled = true

          # DNS and Windows want AlphaNumeric and dashes for hostnames
          c.computer_name = config_value(:chef_node_name).gsub(/\W/,"-")
          c.enabled = true
          c.save
        end

        def bootstrap_ip_address
          vm.reload
          vm.ip_address
        end

        def validate!
          # FIXME: validation is broken atm
          return true
          super(:vchs_username, :vchs_password, :vchs_api_url)
        end
      end
    end
  end
end
